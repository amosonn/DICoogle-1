/*  Copyright   2010 - IEETA
 *
 *  This file is part of Dicoogle.
 *
 *  Author: Luís A. Bastião Silva <bastiao@ua.pt>
 *
 *  Dicoogle is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Dicoogle is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Dicoogle.  If not, see <http://www.gnu.org/licenses/>.
 */



/*
 * TaskList.java
 *
 * Created on Jul 20, 2010, 10:21:21 AM
 */

package pt.ua.dicoogle.rGUI.client.windows;

import java.rmi.NoSuchObjectException;
import java.rmi.RemoteException;
import java.rmi.server.RMISocketFactory;
import java.rmi.server.UnicastRemoteObject;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.DefaultListModel;
import javax.swing.JLabel;
import javax.swing.JProgressBar;
import pt.ua.dicoogle.rGUI.MultihomeRMIClientSocketFactory;
import pt.ua.dicoogle.rGUI.client.AdminRefs;
import pt.ua.dicoogle.rGUI.client.signals.TaskListSignal;
import pt.ua.dicoogle.rGUI.interfaces.controllers.ITaskList;
import pt.ua.dicoogle.rGUI.interfaces.signals.ITaskListSignal;

/**
 *
 * @author Luís A. Bastião Silva <bastiao@ua.pt>
 */
public final class TaskList extends javax.swing.JFrame {

    private static ITaskList taskList;
    private static ITaskListSignal tasksSignal;

    private static TaskList instance = null;

    /** Creates new form TaskList */
    private TaskList()
    {
        initComponents();
        setTitle("Index Status");
        
        jLabel2.setVisible(false);
        jListQueue.setVisible(false);

        registerRemoteObject();
        getTaskList();

    }

    public static synchronized TaskList getInstance()
    {
        if (instance==null)
        {
            instance = new TaskList();
        }
        return instance;
    }


    


    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        progressBar = new javax.swing.JProgressBar();
        jScrollPane1 = new javax.swing.JScrollPane();
        jListQueue = new javax.swing.JList();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();

        progressBar.setStringPainted(true);

        jListQueue.setEnabled(false);
        jScrollPane1.setViewportView(jListQueue);

        jLabel1.setText("Progress:");

        jLabel2.setText("Itens in Queue:");
        jLabel2.setEnabled(false);

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 304, Short.MAX_VALUE)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, layout.createSequentialGroup()
                        .add(jLabel2)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 209, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                    .add(org.jdesktop.layout.GroupLayout.LEADING, jLabel1)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, progressBar, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 304, Short.MAX_VALUE))
                .add(11, 11, 11))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .add(jLabel1)
                .add(2, 2, 2)
                .add(progressBar, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                .add(jLabel2)
                .add(2, 2, 2)
                .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 36, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JList jListQueue;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JProgressBar progressBar;
    // End of variables declaration//GEN-END:variables

   

    private void registerRemoteObject()
    {
       taskList =  AdminRefs.getInstance().getTaskList();

       try
       {
            tasksSignal = new TaskListSignal(this);
            
            ITaskListSignal tasksSignalStub = (ITaskListSignal) UnicastRemoteObject.exportObject(tasksSignal, 0, new MultihomeRMIClientSocketFactory(), RMISocketFactory.getDefaultSocketFactory());
            
            taskList.RegisterSignalBack(tasksSignalStub);

        }
        catch (RemoteException ex) {
            Logger.getLogger(Logs.class.getName()).log(Level.SEVERE, null, ex);
        }

    }

    public void getTaskList()
    {
        ArrayList<String> arrList = null;
        boolean indexing = false;
        int percent = 0 ;
        
        try
        {
            /*
             * For now, get the TaksList is not important
             * Only delays the process
             */
            //arrList = taskList.getTaskList();
            indexing = taskList.isIndexing();
            percent = taskList.getPercentCompleted();

        }
        catch (RemoteException ex)
        {
            Logger.getLogger(TaskList.class.getName()).log(Level.SEVERE, null, ex);
        }


        if (indexing)
        {
            progressBar.setValue(percent);
        }
        else
            progressBar.setValue(100);

        
        progressBar.revalidate();
        
        //updateListQueue(arrList);
        
        
        validate();
        repaint();
    }

    private void updateListQueue(ArrayList<String> list){
        DefaultListModel model = new DefaultListModel();

        for (String s : list )
            model.addElement(s);

        jListQueue.setModel(model);
        jListQueue.revalidate();
    }

}
